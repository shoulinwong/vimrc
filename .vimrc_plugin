" NERD_tree {{{
let NERDTreeWinSize=40
let NERDTreeDirArrows=0
let NERDTreeHighlightCursorline=0
let NERDTreeMapJumpNextSibling=""
let NERDTreeMapJumpPrevSibling=""
let NERDTreeIgnore=['\.o$[[file]]', '\.pyc$[[file]]']
nmap <silent><F7> :NERDTreeToggle<CR>
map <silent><C-n> :NERDTreeToggle<CR>
" }}}

" Tagbar {{{
nmap <silent><F8> :TagbarToggle<CR>
map <silent><C-s> :TagbarToggle<CR>
let g:tagbar_ctags_bin = $VIMFILES.'/tools/ctags'
let g:tagbar_left = 1
let g:tagbar_hide_nonpublic = 0
let g:tagbar_autoshowtag = 1
let g:tagbar_show_visibility = 0
let g:tagbar_iconchars = ['▶ ', '▼ ']
let g:tagbar_compact = 1
let g:tagbar_sort = 0

let g:tagbar_type_typescript = {
  \ 'ctagstype': 'typescript',
  \ 'kinds': [
    \ 'c:classes',
    \ 'n:modules',
    \ 'f:functions',
    \ 'v:variables',
    \ 'v:varlambdas',
    \ 'm:members',
    \ 'i:interfaces',
    \ 'e:enums',
  \ ]
\ }
" }}}

"lightline {{{
let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
    return lightline#statusline(0)
endfunction

let g:lightline = {
            \ 'colorscheme': 'landscape',
            \ 'mode_map': { 'c': 'NORMAL' },
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'fugitive' ],
            \             [ 'filename' ] ],
            \  'right': [ [ 'lineinfo' ],
            \             [ 'percent' ],
            \             [ 'filetype', 'fileformat', 'fileencoding' ] ]
            \ },
            \ 'component_function': {
            \   'filename': 'LightlineFilename',
            \   'modified': 'LightLineModified',
            \   'readonly': 'LightLineReadonly',
            \   'fugitive': 'LightLineFugitive',
            \   'fileformat': 'LightLineFileformat',
            \   'filetype': 'LightLineFiletype',
            \   'fileencoding': 'LightLineFileencoding',
            \   'mode': 'LightLineMode',
            \ },
            \ }

function! LightLineModified()
    return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : ''
endfunction

function! LightLineReadonly()
    if has('nvim')
        return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? '' : ''
    else
        return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'RO' : ''
    endif
endfunction

function! LightLineFugitive()
    if &ft !~? 'vimfiler\|gundo' && exists("*fugitive#head")
        let branch = fugitive#head()
        if has('nvim')
            return branch !=# '' ? ' '.branch : ''
        else
            return branch !=# '' ? branch : ''
        endif
    endif
    return ''
endfunction

function! LightLineFileformat()
    return winwidth(0) > 120 ? &fileformat : ''
endfunction

function! LightLineFiletype()
    return winwidth(0) > 120 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
endfunction

function! LightLineFileencoding()
    return winwidth(0) > 120 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightLineMode()
    return winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! LightlineFilename()
    return ('' != expand('%') ? expand('%') : '[No Name]') .
         \ ('' != LightLineReadonly() ? ' ' . LightLineReadonly() : '') .
         \ ('' != LightLineModified() ? ' ' . LightLineModified() : '')
endfunction

"}}}

"markdown {{{
let g:vim_markdown_folding_disabled = 1
"}}}

"fzf{{{
let g:fzf_command_prefix = 'Fzf'

if executable('rg')
    let $FZF_DEFAULT_COMMAND='rg --files --hidden --follow --ignore-file ' . expand('$VIMFILES/tools/.ignore')
elseif executable('ag')
    let $FZF_DEFAULT_COMMAND='ag --hidden  --path-to-ignore ' . expand('$VIMFILES/tools/.ignore') . ' -g ""'
endif

if !has('win32')
    let g:fzf_colors =
        \{'fg':      ['fg', 'Normal'],
        \ 'bg':      ['bg', 'Normal'],
        \ 'hl':      ['fg', 'Comment'],
        \ 'fg+':     ['fg', 'CursorLine', 'CursorColum', 'Normal'],
        \ 'bg+':     ['bg', 'Title'],
        \ 'hl+':     ['fg', 'Statement'],
        \ 'info':    ['fg', 'PreProc'],
        \ 'prompt':  ['fg', 'Conditional'],
        \ 'pointer': ['fg', 'Exception'],
        \ 'marker':  ['fg', 'Keyword'],
        \ 'spinner': ['fg', 'Label'],
        \ 'header':  ['fg', 'Comment'] }
endif

map <silent><c-p> :FzfFiles<CR>
map <silent><c-b> :FzfBuffers<CR>

" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)

" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)
"}}}

"Ack{{{
let g:ack_mappings = {
      \ "t": "<C-W><CR><C-W>T",
      \ "T": "<C-W><CR><C-W>TgT<C-W>j",
      \ "o": "<CR>",
      \ "O": "",
      \ "go": "",
      \ "h": "",
      \ "H": "",
      \ "v": "",
      \ "gv": "",
      \ "i": "<C-W><CR><C-W>K",
      \ "gi": "<C-W><CR><C-W>K<C-W>b",
      \ "s": "<C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t",
      \ "gs": "<C-W><CR><C-W>H<C-W>b<C-W>J" }

if executable('rg')
    let g:ackprg = 'rg --vimgrep --no-heading --ignore-file ' . expand('$VIMFILES/tools/.ignore')
elseif executable('ag')
    let g:ackprg = 'ag --vimgrep --path-to-ignore ' . expand('$VIMFILES/tools/.ignore')
endif
"}}}

"python-mode{{{
let g:pymode_options_colorcolumn=0
let g:pymode_folding = 1
let g:pymode_rope_auto_project = 0
let g:pymode_rope_goto_definition_bind = "<C-]>"
let g:pymode_rope_goto_definition_cmd = 'e'
let g:pymode_rope_regenerate_on_write = 0
let g:pymode_options_max_line_length = 100
let g:pymode_lint = 1
let g:pymode_lint_on_write = 1
let g:pymode_lint_checkers = ['pyflakes', 'pep8', 'mccabe', 'pylint']
let g:pymode_lint_options_mccabe = {'complexity': 8}
" Using local .pylintrc
let g:pymode_lint_options_pylint = {'rcfile': ''}
"}}}

"vim-go{{{
let g:go_fmt_command = "goreturns"
let g:go_autodetect_gopath = 1
let g:go_list_type = "quickfix"

let g:go_metalinter_enabled = ['vet', 'golint', 'errcheck']
" let g:go_metalinter_autosave = 1
" let g:go_metalinter_autosave_enabled = ['vet', 'golint']
" let g:go_metalinter_disabled = []
let g:go_metalinter_command = '--enable vet --enable golint --enable errcheck --exclude comment --exclude check'
let g:go_metalinter_deadline = '5s'

augroup go
    autocmd!

    autocmd FileType go nmap <C-g> :GoDeclsDir<cr>

    autocmd FileType go nmap <leader>b <Plug>(go-build)
    autocmd FileType go nmap <leader>r <Plug>(go-run)
    autocmd FileType go nmap <leader>t <Plug>(go-test)
    autocmd FileType go nmap <Leader>c <Plug>(go-coverage-toggle)
    autocmd FileType go nmap <Leader>i <Plug>(go-info)
    autocmd FileType go nmap <Leader>l <Plug>(go-metalinter)

    " :GoAlternate  commands :A, :AV, :AS and :AT
    autocmd Filetype go command! -bang A call go#alternate#Switch(<bang>0, 'edit')
    autocmd Filetype go command! -bang AV call go#alternate#Switch(<bang>0, 'vsplit')
    autocmd Filetype go command! -bang AS call go#alternate#Switch(<bang>0, 'split')
augroup END

"}}}
